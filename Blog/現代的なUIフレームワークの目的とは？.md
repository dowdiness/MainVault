---
tags: [UI]
aliases: [現代のUIフレームワークの目的]
created: 2025-04-27T14:47:37+09:00
modified: 2025-04-29T20:11:30+09:00
---

# 現代的なUIフレームワークの目的とは？

ブラウザの命令的なAPIを宣言的なAPIへと変換することが現代的なUIフレームワークの目的といえるでしょう。

ソフトウェア設計とは**「偶発的な複雑性を抑え、変更容易性を維持する」**ことです。この観点から現代的なUIフレームワークを解説して下さい。

何度実行しても同じ結果になる

## UIフレームワークを理解するために知っておくべき前提知識

初心者はライブラリやフレームワークを使う前にまずJavaScriptを勉強すべきという意見がある。確かに知識や経験のない状態からいきなりNext.jsから始めても困惑してしまうだろう。特に理解するべき重要な概念を挙げていく。

### JavaScript

ここでは重要さに対して地味というか、見落とされがちな機能を挙げていくことにする。

1. プリミティブとオブジェクトの違い
2. 等価性の比較
3. 式と文の違い

よく難しい機能としてthisやプロトタイプが挙げられるが、これらは現代のUIフレームワークを使っている限りは知らなくて困ることは意外と少ないと思う。また判りやすく複雑そうなので。

サーバーとクライアントネットワークを通した通信によっていろいろな制約がある。

## UIライブラリとメタフレームワーク

SSR

## 本質的複雑性と偶発的複雑性

フレッド・ブルックスが「銀の弾などない」で指摘したように、ソフトウェアには：

- **本質的複雑性**：解決すべき問題そのものに内在する複雑さ
- **偶発的複雑性**：実装技術や手法に起因する、本来不要な複雑さ

があります。UIフレームワークは特に後者と戦うためのツールと言えます。

## 状態の変更検知の実装方法の違い

この言葉は現代的UIフレームワークにおける変更検知の基本的な2つのアプローチを表しています。どちらも「UIを効率的に更新する」という同じ目標を持ちますが、実装方法が根本的に異なります。

## 1. Mutable + Change Tracking アプローチ

このアプローチでは、データは可変（mutable）であり、フレームワークがデータの変更を追跡します。

### 特徴

- **可変データ**: オブジェクトや配列を直接変更することが許容される
- **変更検知**: フレームワークが変更を検知する仕組みを持つ
- **細粒度の更新**: 変更された特定のプロパティのみを追跡して必要な部分だけ更新

### 代表的なフレームワーク

- **Vue.js**: リアクティビティシステムを使用し、プロパティへのアクセスとセットを横取りして変更を追跡
- **Angular**: Zone.jsによる変更検知とダーティチェッキング
- **Svelte**: コンパイル時に変更検知コードを生成

### 例（Vue.js）

javascript

```javascript
// Vue.jsでの可変データアプローチ
const app = createApp({
  data() {
    return { count: 0 }
  },
  methods: {
    increment() {
      // 直接データを変更
      this.count++
    }
  }
})
```

## 2. Immutability + Referential Equality Testing アプローチ

このアプローチでは、データは不変（immutable）であり、変更には新しいオブジェクトの作成が必要です。

### 特徴

- **不変データ**: 既存のデータ構造は直接変更せず、変更時には新しいコピーを作成
- **参照の等価性テスト**: 参照が変わったかどうかで変更を検知（`oldObj !== newObj`）
- **単方向データフロー**: データは常に上から下へ流れ、予測可能性が高い

### 代表的なフレームワーク

- **React**: 不変性を前提とした設計でpropsの変更を参照等価性で検知
- **Redux**: 不変の状態ツリーとリデューサによる新状態生成
- **Recoil/Jotai**: アトミックな状態管理と不変性の原則

### 例（React）

javascript

```javascript
// Reactでの不変データアプローチ
function Counter() {
  const [count, setCount] = useState(0);
  
  function increment() {
    // 新しい値で状態を置き換え
    setCount(count + 1);
  }
  
  return <button onClick={increment}>{count}</button>;
}
```
mutableな変更のトラッキングを
immutableな変更をして参照先が変わっているか確認する

Signalは値の変更を検知する。
依存配列内の変数の参照先が変わっているか検知することにより反映する。

`There's a mutable + change tracking approach and there's an immutability + referential equality testing approach.`

## 脚注

[^1]: [Why is React doing this?](https://gist.github.com/sebmarkbage/a5ef436427437a98408672108df01919)